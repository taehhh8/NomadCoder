"use client";
// this component is client interactive
// this component is hydrated

import Link from "next/link";
import { usePathname } from "next/navigation";
import { useState } from "react";

export default function Navigation() {
  const path = usePathname();
  const [count, setCount] = useState(0);

  //   console.log(path);
  //   console.log("hello");
  return (
    <nav>
      <ul>
        <li>
          <Link href='/'>Home</Link> {path === "/" ? "🔥" : ""}
        </li>
        <li>
          <Link href='/about-us'>About</Link> {path === "/about-us" ? "🔥" : ""}
        </li>
        <li>
          <Link href='/contact'>Contact</Link> {path === "/contact" ? "🔥" : ""}
        </li>
        <li>
          <button onClick={() => setCount((prev) => prev + 1)}>{count}</button>
          {/* Javscript disable 하면 버튼 클릭 안됨 */}
          {/* about-us ---------> <button>0</button> -----------> :) -----------><button onClick={() => setCount((prev) => prev + 1)}>1</button> */}
          {/* hydration 문제 발생 
          hydration 문제 해결 방법 : 
          - 컴포넌트 최상단에 'use client' 추가
          */}
        </li>
      </ul>
    </nav>
  );
}

// CSR : Client Side Rendering 브라우저가 렌더링
// SSR : Server Side Rendering 서버가 렌더링
// 렌더링이란?
// NextJS가 리액트 컴포넌트를 브라우저가 이해할 수 있는 html로 변환하는 작업

// CSR
// 모든 렌더링이 클라이언트 측에서 발생
// 클라이언트는 자바스크립트를 로드하고, 자바스크립트가 UI를 빌드함

// SSR
// NextJS로 웹 사이트를 빌드할 때, 기본적으로 SSR을 사용함

// Nextjs에서 모든 컴포넌트와 페이지들은 먼저 서버에서 렌더됨
// ('use client' 사용 여부와 상관없음)
// 하이드레이션(Hydration)이란?

// 서버사이드 렌더링(SSR)을 통해 만들어 진 인터랙티브 하지 않는 HTML을 클라이언트 측 자바스크립트를 사용하여 인터랙티브한 리액트 컴포넌트로 변환하는 과정을 말한다.
// (서버 환경에서 이미 렌더링된 HTML에 React를 붙이는 것)
// user /about-us -------------> Boring HTML -------------> :) -----------------> init(Boring HTML) 렌더링 후 클라이언트 측에서 자바스크립트를 통해 인터랙티브한 컴포넌트로 변환

//  nextjs가 render 하는 방법
// 1. 서버사이드 렌더링(SSR)
// 2. 스태틱 사이트 생성(SSG)
// 3. 클라이언트 사이드 렌더링(CSR)

// 서버사이드 렌더링(SSR)
// 서버에서 렌더링 된 페이지를 클라이언트에 전달
// 클라이언트는 서버에서 받은 페이지를 그대로 표시
// 클라이언트는 서버에서 받은 페이지를 그대로 표시

// client component 이든 server component 이든 모두 backend에서 SSR 방식으로 렌더링 됨
// "use client" 가 중요한 이유는 어떤 component가 hydrate되는지 어떤것이 interactive를 필요로 하는지 알려줘야하기 때문에

// nextjs 는 layout 컴포넌트에 있는 export된 default 컴포넌트를 렌더링 함 그다음 URL을 확인하고 그에 맞는 컴포넌트를 렌더링 함
// <Layout>
//   <Navigation/>
//   <Home/>
// </Layout>
//  layout.tsx에 있는 <body>안의 {children} 에 해당하는 컴포넌트를 렌더링 함
// 그래서 layout.tsx에 있는 컴포넌트들은 모두 서버사이드 렌더링(SSR) 방식으로 렌더링 됨

// about-us에만 가능한 layout을 만드려면
//  about-us 폴더에 layout.tsx 파일을 만들면 됨
//about-us 폴더에 하위 폴더를 만들어도 layout.tsx 파일이 있으면 그 폴더에 있는 layout.tsx 파일을 렌더링 함

/* <Layout>
    <AboutUsLayout>
      <SalesLayout>
        <Sales />
      </SalesLayout>
    </AboutUsLayout>
</Layout> */

// routes group를 그룹화해서 logical group으로 만들어줌
// (home) 만들어서 page.tsx를 넣어주면 그 폴더에 있는 모든 페이지들이 그룹화 됨
//  layout.tsx와 not-found.tsx 파일은 그대로 있어야한다.

// metadata 는 페이지에 대한 정보를 제공하는 객체
// export const metadata = {
//     title:"Next.js",
//     description:"Generated by Next.js"
// }

// metadata는 page의 header에 표시된다.
// 컴포넌트에서는 metadata를 내보낼 수 없고 또 metadata는 서버 컴포넌트에만 있을수 있다.
//

// export const metadata: Metadata = {
//     title: {
//       template: "%s | Next Movies",
//       default: "Next Movies",
//     },
//     description: "The Best Movies on the best framework",
//   };

//각각의 layout에 metadata의 title을 중복할 필요없이 template을 사용해서 중복을 피할 수 있다.

// metadata에는 여러가지가 들어갈수있다.
// nextjs metadata 공식문서
// https://nextjs.org/docs/app/building-your-application/optimizing/metadata

// dynamic routes
// 동적 라우팅
// 동적 라우팅은 페이지를 렌더링 하기 전에 데이터를 가져오는 방법
// 예를 들어 영화 아이디를 가져오는 방법

// /movies/:id ---> <Movie/>
// /(movies)/movies/[id]
// [id] 중괄호는 필수

// export default function MovieDetail({ params: { id } }: { params: { id: string } }) {
//     return <div>Movie {id}</div>;
//   }

// 이렇게하면 /movies/123123123 입력하면 id가 123123123을 출력한다.
//<MovieDetail params={{id:"123123123"}}/>
// 이렇게 하면 컴포넌트에 파라미터를 넘겨줄 수 있다.


// 2024/11/13

